////////////////////////////////////////////////////////////////////////
// Class:       WaveformPreProcessing
// Module Type: producer
// File:        WaveformPreProcessing_module.cc
//
// Generated at Tue Feb  3 04:38:15 2026 by Laura Paulucci using artmod
// from cetpkgsupport v1_14_01.
// This module works on data waveforms and can perform two tasks
// 1. Remove baselines that fluctuate with time (code developed by A. Paudel)
// 2. Use a denoising algorithm (the same one used in PDSP) to make
// waveforms smoother (fhicl adjustable)
// This module produces a new set of OpDetWaveforms that should be
// used as input to the OpHitFinder
// TO DO: Implement a ROI finder to decrease the size of the optical
// waveform collection
////////////////////////////////////////////////////////////////////////

//LArSoft includes
#include "lardataobj/RawData/OpDetWaveform.h"
#include "larcore/CoreUtils/ServiceUtil.h"
#include "larcore/Geometry/WireReadout.h"

//Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Persistency/Common/PtrMaker.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/Exception.h"
#include "cetlib_except/exception.h"

//C++ includes
#include <memory>
#include <cmath>
#include <fstream>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>

//ROOT includes
#include "TH1D.h"

namespace opdet{

  class WaveformPreProcessing;

  class WaveformPreProcessing : public art::EDProducer {
  public:
    WaveformPreProcessing(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    WaveformPreProcessing(WaveformPreProcessing const &) = delete;
    WaveformPreProcessing(WaveformPreProcessing &&) = delete;
    WaveformPreProcessing & operator = (WaveformPreProcessing const &) = delete;
    WaveformPreProcessing & operator = (WaveformPreProcessing &&) = delete;

    // Required functions.
    void produce(art::Event & evt) override;
    void BaselineExtractor(std::vector<double>& wf);
    void DenoisingAlgo(std::vector<double>& waveform, double lambda);
    bool TV1D_denoise(std::vector<double>& waveform, std::vector<double>& outwaveform, const double lambda);
    std::vector<double> ComputeMovingAverage(const std::vector<double>& data, int n);
    double median_func(std::vector<double> vec, double fraction);
    std::vector<double> trailing_min(const std::vector<double>& x, int L);
    std::vector<double> trailing_max(const std::vector<double>& x, int L);
    std::vector<double> centered_min(const std::vector<double>& x, int L);
    std::vector<double> centered_max(const std::vector<double>& x, int L);
    std::vector<double> EstimateBaselineOpeningCentered(const std::vector<double>& wave, int L, int smooth_ma);
    std::vector<short> VectorOfDoublesToVectorOfShorts (std::vector<double> const& vectorOfDoubles);

  private:
    // Declare member data here.
    // The parameters we'll read from the .fcl file.
    std::string fInputModule; // Input tag for OpDetWaveform collection
    bool fApplyDenoising;
    bool fIsPDVD;
    double fLambda;
    int fMaxTicks;
    double fSecondBaselineSub;
    double fFirstBaselineSub;
  };
}//namespace opdet

namespace opdet {

  DEFINE_ART_MODULE(WaveformPreProcessing)

}

namespace opdet {

  WaveformPreProcessing::WaveformPreProcessing(fhicl::ParameterSet const &p)
   : EDProducer{p}
  // Initialize member data here.
  {
    // Indicate that the Input Module comes from .fcl
    fInputModule        = p.get<std::string>("InputModule"); 
    fApplyDenoising     = p.get<bool>("ApplyDenoising"); 
    fIsPDVD             = p.get<bool>("IsPDVD"); 
    fLambda             = p.get<double>("Lambda"); //parameter for the denoising algorithm
    fMaxTicks           = p.get<int>("MaxTicks"); //maximum number of ticks in the waveform
    fSecondBaselineSub  = p.get<double>("SecondBaselineSub"); //the mode of lowest SecondBaslineSub of the signal for second baseline estimate
    fFirstBaselineSub   = p.get<double>("FirstBaselineSub"); //around 3 times the expected large signals
  
    // This module produces (infrastructure piece)
    produces< std::vector< raw::OpDetWaveform > >();

  }

  void WaveformPreProcessing::produce(art::Event & evt)
  {
    // A pointer that will store produced OpDetWaveforms
    auto ProcessedWaveformVector = std::make_unique< std::vector< raw::OpDetWaveform > >(); 

    std::cout << "\nRunning Waveform Pre Processing\n";
    // Load pulses into WaveformVector
    art::Handle<std::vector<raw::OpDetWaveform>> wvfHandle;
    evt.getByLabel(fInputModule,wvfHandle);

    assert(wvfHandle.isValid());

    // Reserve a large enough array
    // TODO: Commented out int totalsize to fix unused variable build error in clang.
    //       Uncomment when implementing the full logic.
    //int totalsize = 0;
    //totalsize += wvfHandle->size();
    std::vector<double> fwaveform;
    fwaveform.reserve(fMaxTicks); 

    for (auto const& wf : *wvfHandle) {

      if (wf.size() == 0 ) {
        mf::LogInfo("WaveformPreProcessing") << "Empty waveform, continue.";
        continue;
      }

      fwaveform.resize(wf.size());
      for(unsigned int i = 0; i < wf.size(); i++) { //converting raw::OpDetWaveform to std::vector
        fwaveform[i] = wf[i];
      }

      if (fIsPDVD && wf.ChannelNumber() > 3000 ) { //Excluding PMTs from the pre processing in PDVD
      }else{
        if (fApplyDenoising){
          double lambda = fLambda;
          DenoisingAlgo(fwaveform, lambda);
        }
        BaselineExtractor(fwaveform);
      }
      std::vector< short > waveformOfShorts = VectorOfDoublesToVectorOfShorts(fwaveform);

      raw::OpDetWaveform fprocessedWf(wf.TimeStamp(), wf.ChannelNumber(), waveformOfShorts.size());
      for(unsigned int i = 0; i < waveformOfShorts.size(); i++) {
        fprocessedWf.emplace_back(waveformOfShorts[i]);
      }

      ProcessedWaveformVector->push_back(std::move(fprocessedWf));
      fwaveform.clear();
      fprocessedWf.clear();
    }

    // Push the OpDetWaveforms into the event
    evt.put(std::move(ProcessedWaveformVector));

  }

  void WaveformPreProcessing::BaselineExtractor(std::vector<double> &wf){
    std::vector<double> signal_base, waveform_full_bs;
    std::vector<double> temp = wf; 
    //MA, baseline estimate, basline subtraction
    std::vector<double> signalsma = ComputeMovingAverage(temp, 4);
    std::vector<double> basev = EstimateBaselineOpeningCentered(signalsma, fFirstBaselineSub, 1);
    for (size_t j=0; j<signalsma.size(); ++j){
      signal_base.push_back(signalsma.at(j)-basev.at(j));
    }
    double base = median_func(signal_base, fSecondBaselineSub);
    for (size_t j=0; j<signalsma.size(); ++j){
      waveform_full_bs.push_back(signal_base.at(j)-base);
    }
    wf = waveform_full_bs;
  }

  void WaveformPreProcessing::DenoisingAlgo(std::vector<double> &waveform, double lambda){
    int length = waveform.size();
    std::vector<double> outwaveform; 
    outwaveform = waveform;  // copy
    const uint retries = 5; uint try_ = 0;
    if (length > 0) {
      while (try_ <= retries) {
        if (TV1D_denoise(waveform, outwaveform, lambda)) break;
        try_++;
        mf::LogInfo("WaveformPreProcessing") << try_ << "/" << retries
                                   << " Coming out of TV1D_denoise() unsuccessfully, "
                                   << "using lambda: " << lambda;
        lambda += 0.1 * lambda;
        if (try_ == retries) mf::LogWarning("WaveformPreProcessing") <<  "Couldn't denoise!";
      }
    }

    for(int i = 0; i < length; i++) { //replacing non-zero entries
      if(outwaveform[i]) waveform[i] = outwaveform[i];
    }
  }

  bool WaveformPreProcessing::TV1D_denoise(std::vector<double>& waveform,
                                     std::vector<double>& outwaveform,
                                     const double lambda)
  {
    int width = waveform.size();
    int k = 0, k0 = 0; // k: current sample location, k0: beginning of current segment
    double umin = lambda, umax = -lambda; // u is the dual variable
    double vmin = waveform[0] - lambda, vmax = waveform[0] + lambda; // bounds for the segment's value
    int kplus = 0, kminus = 0; // last positions where umax=-lambda, umin=lambda, respectively
    const double twolambda = 2.0 * lambda; // auxiliary variable
    const double minlambda = -lambda; // auxiliary variable
    for (;;) { // simple loop, the exit test is inside
      while (k == width - 1) { // we use the right boundary condition
        if (umin < 0.0) { // vmin is too high -> negative jump necessary
          do outwaveform[k0++] = vmin; while (k0 <= kminus);
          umax = (vmin = waveform[kminus = k = k0]) + (umin = lambda) - vmax;
        }
        else if (umax > 0.0) { // vmax is too low -> positive jump necessary
          do outwaveform[k0++] = vmax; while (k0 <= kplus);
          umin = (vmax = waveform[kplus = k = k0]) + (umax = minlambda) - vmin;
        }
        else {
          vmin += umin / (k - k0 + 1);
          do outwaveform[k0++] = vmin; while(k0 <= k);
          return true;
        }
      } // while (k == width - 1)
      if ((umin += waveform[k + 1] - vmin) < minlambda) { // negative jump necessary
        if (k0 > width) return false;
        do outwaveform[k0++] = vmin; while (k0 <= kminus);
        vmax = (vmin = waveform[kplus = kminus = k = k0]) + twolambda;
        umin = lambda; umax = minlambda;
      }
      else if ((umax += waveform[k + 1] - vmax) > lambda) { // positive jump necessary
        if (k0 > width) return false;
        do outwaveform[k0++] = vmax; while (k0 <= kplus);
        vmin = (vmax = waveform[kplus = kminus = k = k0]) - twolambda;
        umin = lambda; umax = minlambda;
      }
      else {   //no jump necessary, we continue
        k++;
        if (k > width) return false;
        if (umin >= lambda) { // update of vmin
          vmin += (umin - lambda) / ((kminus = k) - k0 + 1);
          umin = lambda;
        }
        if (umax <= minlambda) { // update of vmax
          vmax += (umax + lambda) / ((kplus = k) - k0 + 1);
          umax = minlambda;
        }
      }
    } // for (;;)
  } // TV1D_denoise()

  //moving average function
  std::vector<double> WaveformPreProcessing::ComputeMovingAverage(const std::vector<double>& data, int n) {
    std::vector<double> result;
    const int size = static_cast<int>(data.size());
    if (n <= 0 || size == 0) return result;
    result.resize(size);
    double sum = 0.0;
    int window = 0;  // current window length (<= n)

    // For index i, average over [max(0, i-n+1) ... i]
    for (int i = 0; i < size; ++i) {
      sum += data[i];
      ++window;
      if (window > n) {         // keep window length at most n
        sum -= data[i - n];
        --window;
      }
      // For i < n-1, window grows from 1..n; afterwards it's fixed at n.
      result[i] = sum / window;
    }

    return result;
  }

  //mode value baseline function
  double WaveformPreProcessing::median_func(std::vector<double> vec, double fraction) {
    if (vec.empty()) return 0;
    std::sort(vec.begin(), vec.end());
    size_t n = vec.size();
    size_t cutoff = static_cast<size_t>(n * fraction);
    if (cutoff == 0) cutoff = 1;
    std::vector<double> lowest(vec.begin(), vec.begin() + cutoff);
    TH1D *fhist=new TH1D("fhist","",100,-50,50);
    for(size_t k=0;k<lowest.size();k++) fhist->Fill(lowest.at(k));
    double mode_center = fhist->GetBinCenter(fhist->GetMaximumBin());
    fhist->Delete();
    return mode_center;
  }

  /////baseline estimate//////
  ////baseline subtraction
  // ---- Core trailing-window sliding min/max (as before) ----
  std::vector<double> WaveformPreProcessing::trailing_min(const std::vector<double>& x, int L) {
    const int N = static_cast<int>(x.size());
    if (N == 0) return {};
    if (L <= 1) return x;
    L = std::min(L, N);

    std::vector<double> y(N);
    std::deque<int> dq; // indices with nondecreasing values

    for (int i = 0; i < N; ++i) {
      while (!dq.empty() && x[i] <= x[dq.back()]) dq.pop_back();
      dq.push_back(i);
      const int oldest = i - L + 1;
      while (!dq.empty() && dq.front() < oldest) dq.pop_front();
      y[i] = x[dq.front()];
    }
    return y;
  }

  std::vector<double> WaveformPreProcessing::trailing_max(const std::vector<double>& x, int L) {
    const int N = static_cast<int>(x.size());
    if (N == 0) return {};
    if (L <= 1) return x;
    L = std::min(L, N);

    std::vector<double> y(N);
    std::deque<int> dq; // indices with nonincreasing values

    for (int i = 0; i < N; ++i) {
      while (!dq.empty() && x[i] >= x[dq.back()]) dq.pop_back();
      dq.push_back(i);
      const int oldest = i - L + 1;
      while (!dq.empty() && dq.front() < oldest) dq.pop_front();
      y[i] = x[dq.front()];
    }
    return y;
  }

  // ---- Centered versions via "index-ahead" trick ----
  // centered_min[i] â‰ˆ trailing_min(x, L)[ clamp(i + r, 0, N-1) ]
  std::vector<double> WaveformPreProcessing::centered_min(const std::vector<double>& x, int L) {
    const int N = static_cast<int>(x.size());
    if (N == 0) return {};
    if (L <= 1) return x;
    L = std::min(L, N);
    const int r = (L - 1) / 2;

    auto tmin = trailing_min(x, L);
    std::vector<double> y(N);
    for (int i = 0; i < N; ++i) {
      int j = i + r;
      if (j >= N) j = N - 1;
      y[i] = tmin[j];
    }
    return y;
  }

  std::vector<double> WaveformPreProcessing::centered_max(const std::vector<double>& x, int L) {
    const int N = static_cast<int>(x.size());
    if (N == 0) return {};
    if (L <= 1) return x;
    L = std::min(L, N);
    const int r = (L - 1) / 2;

    auto tmax = trailing_max(x, L);
    std::vector<double> y(N);
    for (int i = 0; i < N; ++i) {
      int j = i + r;
      if (j >= N) j = N - 1;
      y[i] = tmax[j];
    }
    return y;
  }

  // ---- Baseline via centered morphological opening ----
  // Optional tiny trailing MA (smooth_ma) to de-jitter the opened floor; set 0 to skip.
  std::vector<double> WaveformPreProcessing::EstimateBaselineOpeningCentered(const std::vector<double>& wave, int L, int smooth_ma = 4) {
    const int N = static_cast<int>(wave.size());
    if (N == 0) return {};
    L = std::max(3, std::min(L, N)); // odd/even both fine

    // Erosion then dilation, both with centered windows
    auto eroded  = centered_min(wave, L);
    auto opened  = centered_max(eroded, L);
  
    if (smooth_ma > 1) {
      std::vector<double> sm(N);
      double run = 0.0;
      int w = 0;
      for (int i = 0; i < N; ++i) {
        run += opened[i];
        ++w;
        if (w > smooth_ma) { run -= opened[i - smooth_ma]; --w;}
          sm[i] = run / w;
        }
      return sm;
    }
    return opened;
  }

  std::vector<short> WaveformPreProcessing::VectorOfDoublesToVectorOfShorts (std::vector<double> const& vectorOfDoubles) 
  {
    // Don't bother to round properly, it's faster this way
    return std::vector<short>(vectorOfDoubles.begin(), vectorOfDoubles.end());
  }

}//namespace opdet
